# -*- coding: utf-8 -*-
"""Qnibbles.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yO-lx3IcuUxb3pblLG5c-iLuDdvLz9I3

**Discuss with Unnati**


*   behavior of temperature, populations relationship to thermal_dm(2,this thing)
*   distance measures already implimented in qutip, vs the one we are using
*   where are our definitions from (i'd like a refrence paper)

# Environment set up
<ul>
<li>install qutip via pip</li>
<li> import qutip, numpy,matplotlib and a few tools from itertools
<ul>
"""

# !pip install qutip

import qutip as q
import numpy as np
from itertools import permutations,groupby
from collections import Counter
import matplotlib.pyplot as plt
from scipy.linalg import logm as sp_logm
# plt.rcParams['figure.figsize'] = [2, 2] # increase default fig size
# plt.rcParams['savefig.bbox'] = 'tight'

"""# Utility functions

<ul>
<li> generate a random complex number </li>
<li> Generate a dennsity matrix of n thermal qubits </li>
<li> impliment logm for qobj </li>
<ul>

"""

def random_complex():
  """Generates a random complex number with the real and complex components between zero and one"""
  return np.random.rand()+1j*np.random.rand()

def logm(dm):
    """Matrix log of quantum operator.

    Input operator must be square.

    Parameters
    ----------
    dm a square density matrix


    Returns
    -------
    oper : :class:`qutip.Qobj`
        Exponentiated quantum operator.

    Raises
    ------
    TypeError
        Quantum operator is not square.

    """
    if dm.dims[0][0] != dm.dims[1][0]:
        raise TypeError('Invalid operand for matrix log')

    F = sp_logm(dm.full())


    out = Qobj(F, dims=dm.dims)
    return out.tidyup()

"""Generating thermal density matrices for n qubits"""

def n_thermal_qubits(temps):
  """takes the tensor product of n thermal qubits at temps"""
  return q.tensor([q.thermal_dm(2,t,"analytic") for t in temps])

def I(n):
  return q.identity([2 for _ in range(n)])

def inverse_order(ord:list)-> list:
  return [ord.index(i) for i in range(len(ord))]

"""# Generating random hamiltonians"""

def random_hamiltonian(nqubit:int, energy:int) -> q.Qobj:
  """Generates a random hamiltonian of nqubits in energy subspace energy"""

  #Becouse Qobj is not hashable the generating sequences are made from charachters and then convert to qobj via this dict
  letter_to_Qobj = {'a':q.Qobj([[1,0],[0,0]]),'b':q.Qobj([[0,1],[0,0]]),'c':q.Qobj([[0,0],[1,0]]),'d':q.Qobj([[0,0],[0,1]])}

  generators = _generating_sequences(nqubit,energy)

  #this creates a list of all abcd sequences in the energy subspace
  sequences_by_generator = [list(permutations(generator.elements())) for generator in generators if generator['b']>0]

  #using a set removes duplicates
  #flattens the list so it is just a list of sequences rather than a list of list of sequences (organized by which generator they are from) 
  sequences = set([sequence for sequences in sequences_by_generator for sequence in sequences])

  #take the tensor product of each abcd sequence scaled by a random complex number
  non_hermitian_transformation = sum([random_complex()*q.tensor(*[letter_to_Qobj[letter] for letter in sequence]) for sequence in sequences])

  #to enforce hermiticity, add the conjugate transpose to the result
  return(non_hermitian_transformation+non_hermitian_transformation.dag())

def _generating_sequences(nqubit:int, energy:int):
  """creates multi sets of abcd sequences to be used as generators. 
  Works by recursivly generating abcd sequences for lower energy subspaces and adding one element that will increase the energy by one.

   **a**: **0**->**0**
   **b**: **1**->**0**
   **c**: **0**->**1**
   **d**: **1**->**1**

   a sequence of all "a"s is in energy subspace zero. 
   By replacing one "a" with a "d" we increase the energy subspace by one. 
   By replacing two "a"s with a "b" and a "c" it increases the energy subspace by one.

  """

  #cant have more energy than qubits
  assert energy<=nqubit, f"there are {nqubit} qubits with {energy} energy, can't have more energy than qubits"

  #this is the recursive base case
  if energy==0:
    return [Counter(a = nqubit)]


  result = []
  #loop through each generating sequence of one energy level lower
  for sequence in _generating_sequences(nqubit,energy-1):
    s1,s2 = sequence.copy(),sequence.copy()

    #if there is at least one "a" in the sequence
    if s1['a']>0:
      # remove one a, add one d
      s1['a'],s1['d']=s1['a']-1,s1['d']+1

      # add generator to result
      result+=[s1]
    #if there is at least two "a"s in the sequence
    if s2['a']>1:
      #reduce the number of "a"s by two and add a "b" and a "c"
      s2['a'],s2['b'],s2['c']=s2['a']-2,s2['b']+1,s2['c']+1

      # add generator to result
      result+=[s2]

  #the +is a special counter thing that drops zeros.
  return list(+result for result,_ in groupby(result))

"""#thermal propetries"""

from qutip.qobj import Qobj
def temperture(dm:q.Qobj) -> float:
  assert dm.dims == [[2],[2]], f"must be a a density matrix of a single qubit, instead it has dimension {dm.dims}"
  p = dm.data[1,1]
  return 1/np.log((1-p)/p)

def PopFromTemp(T:float)-> float:
  return 1/(np.e**(1/T)+1)

  average

def avg_temp(dm:q.Qobj)-> float:
  return np.mean([temperture(q.ptrace(dm,i)) for i in range(len(dm.dims[0]))])

def temps(dm: q.Qobj) -> float:
  return [temperture(q.ptrace(dm, i)) for i in range(len(dm.dims[0]))]

def distance(dm1:q.Qobj,dm2:q.Qobj) -> float:
  return (dm1*(logm(dm1)-logm(dm2))).tr()

def extractable_work(dm1i,dm2i,dm1f,dm2f):
  T = avg_temp
  return T(dm2f)*distance(dm1f,dm2f)-T(dm2i)*distance(dm1i,dm2i)
